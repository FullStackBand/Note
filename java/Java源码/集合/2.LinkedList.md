# LinkedList源码分析

## 1. 链表介绍

* 链表是一种物理存储单元上非连续、非顺序的存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

* 链表由一系列结点(链表中每一个元素称为结点)组成,结点可以在运行时动态生成。

* 每个结点包括两个部分:一个是存储数据元素的数据域,另一个是存储下一个结点地址的指针域。

* 双链表是链表的一种,由节点组成,每个数据结点中都有两个指针,分别指向直接后继和直接前驱。

  > 模型演示 [https://visualgo.net/zh/list]

##  2. 源码分析

### 1. 构造函数

```java
// 空参
public LinkedList() {
}

public LinkedList(Collection<? extends E> c) {
    this();
    addAll(c);
}

    public boolean addAll(Collection<? extends E> c) {
        return addAll(size, c);
    }
```

###  2. 插入方法

#### 1. 插入1

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}

void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    // 设置新节点是尾节点
    last = newNode;
    // 判断链表是否有元素
    if (l == null)
        first = newNode;
    else
       	// 设置尾节点的后记节点为空
        l.next = newNode;
    size++;
    modCount++;
}
// 内部类
private static class Node<E> {
    E item;// 当前节点
    Node<E> next;// 后继节点
    Node<E> prev;// 前继节点

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

#### 2. 插入2

```java
public void add(int index, E element) {
    // 检查下标是否合法 ( index >=0 && index <= size )
    checkPositionIndex(index);
	// 是否为尾部节点
    if (index == size)
        // 添加到尾部
        linkLast(element);
    else
        // 插入节点
        // element 插入的元素
        // node(index) 原先 这个位置的节点
        linkBefore(element, node(index));
}

void linkBefore(E e, Node<E> succ) {
    // 原来节点的前集节点
    final Node<E> pred = succ.prev;
    // 创建节点 , 原来节点的前节点是新节点的前继节点 , 原来的节点是新节点的后继节点
    final Node<E> newNode = new Node<>(pred, e, succ);
    // 原节点的前节点是新节点
    succ.prev = newNode;
    // 如果原前继节点为空
    if (pred == null)
        // 插入的节点为第一个节点
        first = newNode;
    else
        // 前继节点 的 后继节点 是新节点
        pred.next = newNode;
    // 改变长度
    size++;
    // 修改次数
    modCount++;
}

```

### 3. 删除

#### 1. 删除1

```java
public E remove() {
    return removeFirst();
}
```

#### 2. 删除2

```java
public boolean remove(Object o) {
    if (o == null) {
        for (Node<E> x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for (Node<E> x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}

E unlink(Node<E> x) {
    // assert x != null;
    // x 要删除的节点
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;
	// 是头部节点
    if (prev == null) {
        // 头部节点 = x.后继节点
        first = next;
    } else {
        // x.前继节点的后继节点 = 后继节点
        prev.next = next;
        // x.前继节点 = null
        x.prev = null;
    }
	// 是尾部节点
    if (next == null) {
        // 尾部节点 = x.前继节点
        last = prev;
    } else {
        // x.后继节点.前继节点 = x.前继节点
        next.prev = prev;
        // x.后继节点 = null
        x.next = null;
    }
	// x清空
    x.item = null;
    // 长度减 1
    size--;
    // 修改次数加 1
    modCount++;
    return element;
}
```

####  3. 删除3

```java
public E remove(int index) {
    // 检查index位置 index >= 0 && index < size;
    checkElementIndex(index);
    // 删除(删除2引用的方法)
    return unlink(node(index));
}

```

### 4. 查找

```java
public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}
// 获取index的元素
Node<E> node(int index) {
    // assert isElementIndex(index);
    if (index < (size >> 1)) {
        // 从前面开始找
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        // 从后面开始找
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```



### 5. 遍历

